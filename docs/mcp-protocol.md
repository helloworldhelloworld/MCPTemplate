# MCP 协议参考

本文聚焦 Model Context Protocol（MCP）本身的约定与数据结构，帮助读者在没有具体代码背景的情况下理解协议如何组织一次工具调用的生命周期。

## 协议参与方
- **模型客户端（Model Runtime）**：代表模型或上游应用，负责发起工具调用、订阅事件流、对响应做语义理解。
- **工具服务端（Tool Server）**：承接模型请求，完成鉴权、调度具体工具，并将结果封装成标准响应。
- **共享契约层（Contracts）**：约定上下文字段、数据包形态与错误语义，确保任意客户端与服务端都能按统一格式通信。

## 调用上下文
所有请求都通过 `Context` 携带调用标识与运行时元数据：

- `clientId`、`requestId`、`traceId`：用于追踪、去重与链路串联。
- `timestamp`：ISO-8601 时间戳，保证参与方在时序上的一致性。
- `locale`、`metadata`：面向多语言、多租户等扩展场景的开放字段。
- `usage`：记录 token、延迟等消耗指标，可供计费或 SLA 评估。

客户端在发起请求时写入上述信息，服务端在响应中补充或更新 `usage` 等指标，形成端到端透传。

## Envelope 形态
MCP 通过统一的 Envelope 抽象不同阶段的消息：

- **RequestEnvelope**：封装 `tool` 名称、`Context` 与结构化 `payload`，代表一次工具调用的输入。
- **ResponseEnvelope**：携带 `StdResponse` 与可选的 `UiCard`，用于返回最终结果及界面展示数据。
- **StreamEventEnvelope**：面向长任务或实时推送，包含事件类型、时间戳以及阶段性响应内容。

这些 Envelope 保持字段一致，使 HTTP、gRPC、WebSocket 等传输层可以复用相同的序列化结构。

## 方法族与交互流程
MCP 将交互拆分为一组方法族：

1. `list_tools`：客户端发现工具能力与参数签名。
2. `call_tool`：提交结构化负载，请求执行指定工具。
3. `stream_events`：订阅工具执行过程中的增量事件或心跳。
4. `cancel_call`：在需要时撤销长时间运行的调用。

以翻译或车控场景为例：

- 客户端先调用 `list_tools` 获知 `translation`、`vehicleState` 等工具支持的字段与语言范围。
- 调用 `call_tool` 时，`payload` 中携带翻译的源文本、目标语言，或车辆 VIN、查询参数等业务信息。
- 若工具执行耗时，服务端可通过 `stream_events` 推送阶段性状态（如“翻译进度 50%”、“车辆状态读取中”），最终由 `ResponseEnvelope` 给出完整结果或 UI 卡片。

## JSON Schema 契约
协议推荐使用 JSON Schema 描述工具的入参、出参：

- 公共部分定义 `Context`、`Usage`、`StdResponse` 等基础组件。
- 每个工具声明自身 `payload` 的必填字段、类型范围和枚举值（例如翻译的语言代码、车控的控制指令列表）。
- Schema 可被客户端用于本地校验，也可在服务端对入参做二次验证，确保双方对契约达成共识。

## UI 卡片与展示
`UiCard` 对象封装标题、副标题、正文和交互动作，便于将 MCP 响应直接映射到前端或车载屏幕。例如：

- 翻译结果卡片可以展示源文本、译文以及“复制”操作。
- 车控查询卡片可罗列车辆状态、剩余续航，并附带“刷新”“预约保养”等动作。

## 错误语义与幂等
`StdResponse` 通过 `status`、`code`、`message`、`data` 四个字段表达结果：

- `status` 区分 `SUCCESS`、`FAILED`、`PROCESSING` 等状态。
- `code` 承载业务错误码，便于客户端根据语义采取补偿措施。
- `message` 面向人类可读说明，`data` 存放结构化结果或错误细节。

协议鼓励将 `requestId` 作为幂等键；若客户端重复发送同一请求，服务端可直接返回已缓存的响应，减少重复计算。

## 鉴权与观测
MCP 不强制某种安全方案，但推荐：

- 在 `Context.metadata` 中附带签名信息或租户标识，实现自定义鉴权。
- 使用开放式追踪 ID（如 W3C Trace Context）串联调用链路。
- 将 `usage` 与事件时间戳写回响应，以便观测平台统计性能与成功率。

通过以上约定，任意模型客户端都能在不共享内部实现细节的情况下，与不同领域的工具（翻译、车控、知识库等）建立稳定、可演进的集成关系。
